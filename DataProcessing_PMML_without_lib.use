model DataProcessingPMML
enum OpType{Ordinal, Categorical, Continuous}
enum DataType{String, Time, Integer, DateTime, Boolean, Double, Float}
enum ClosureType{openOpen, openClosed, closedOpen, closedClosed}
enum SpecialType{MissingTo, Default}
enum ValueImpute{Missing, Invalid, Outlier}
enum DerivedType{MostFrequent, Previous, Next}
enum Operation{Interpolation, Mean, Median, Closest}

abstract class DataProcessingElement
	attributes
		name:String
end

abstract class PortType
	attributes
	 index:Integer
end



abstract class DataField
   attributes
	 id:Boolean
	 target:Boolean
	 name:String
	 dataType:DataType
	 displayName:String
end

class ValueField
	attributes
		value:String
		count:Integer
end

class Categorical < DataField
	attributes
		ordinal:Boolean
end

class Continuous < DataField
end

class Interval
	attributes
		leftMargin:Real
		rightMargin:Real
		closure:ClosureType
		count:Integer
end

class Job < DataProcessingElement
end



class MapSpecialValues
	attributes
		value:String
		type:SpecialType
end

class DerivedField
	attributes
		derived_name:String
		derived_dataType:DataType
		derived_opType:OpType
end

class Field 
  attributes
   exclude:Boolean
end

abstract class Parameter
  attributes
    name:String
	required:Boolean
	dataType:DataType
end

class Map < Parameter
	attributes
	 inValue:String
	 outValue:String
end

class PrimitiveValue < Parameter
  attributes
	value:String
end

class MatchingValue < Parameter
end

class FilterType < Parameter
end

class DiscretizeBin < Parameter
	attributes
		binValue:String
end

class MissingValues < MatchingValue
end

class Range < MatchingValue
	attributes
	 min:String
	 max:String
end


class FieldValue < FilterType
end

class RowNumber < FilterType
end

abstract class ImputeType < Parameter
	attributes
		imputeValue: ValueImpute
end

class DerivedValue < ImputeType
	attributes
		value:DerivedType
end

class NumOperation < ImputeType
	attributes
		operation:Operation
end

class Data
	attributes
		value:String
end

aggregation  InputPort between
	DataProcessingElement [1] role dataProcessingInput
	PortType [1..*] role inputPort
end

aggregation  OutputPort between
	DataProcessingElement [1] role dataProcessingOutput
	PortType [1..*] role outputPort
end

aggregation DataDictDataField between
	DataDictionary [1]
	DataField [1..*] role dataFields
end

association MappingSpecialValues between
	Transformation [1]
	MapSpecialValues [0..2]
end

association DerivedFields between
	Transformation [1]
	DerivedField [0..1]
end

association ParameterField between
	Transformation [1]
	Field [1..1] role field
end

aggregation TransfParam between
	Transformation [1]
	Parameter [0..*]
end 

association FieldValueMatchingValue between
	FieldValue [1] 
	MatchingValue [1..*]
end

association RowNumberMatchingValue between
	RowNumber [1]
	Range [1]
end

aggregation JobDop between
	Job [1] role jobDop
	Transformation [1..*] role dopJob
end

aggregation JobJob between
	Job[1]
	Job [0..*] role jobInput
end

association FieldDataField between
    Field[1]
	DataField [1..1] role dataField
end

association DiscretizeInterval between
	DiscretizeBin [1]
	Interval [1]
end

association ContinuousInterval between
	Continuous [1]
	Interval [0..*] role intervals
end

association ValidValues between
	DataField [1] role dataField
	ValueField [0..*] role validValues
end

association InvalidVals between
	DataField [1] role dataField1
	ValueField [0..*] role invalidValues
end

association MissingVals between
	DataField [1] role dataField2
	ValueField [0..*] role missingValues
end

class DataDictionary < PortType
	attributes
	 rows:Integer
	 name:String
	operations
	  getDataField(name : String) : DataField = 
	  self.dataFields->select(dF|dF.name = name)->asSequence->at(1)
end

class Transformation < DataProcessingElement
operations
	getInputDataDictionary(index: Integer) : DataDictionary = 
		self.inputPort->select(ip | ip.oclIsTypeOf(DataDictionary)).oclAsType(DataDictionary)->asSequence->at(index)
	getOutputDataDictionary(index: Integer) : DataDictionary = 
		self.outputPort->select(op | op.oclIsTypeOf(DataDictionary)).oclAsType(DataDictionary)->asSequence->at(index)
	getOutputDataField() : DataField =
		self.getOutputDataDictionary(1).getDataField(self.field.dataField.name)
	validateImpute(imputeType:ImputeType)
	begin end
	pre missing: 
		if imputeType.imputeValue  = ValueImpute::Missing
		then
			self.field.dataField.missingValues->size() >=1
		else
			true
		endif
	pre invalid:
		if imputeType.imputeValue  = ValueImpute::Invalid
		then
			self.field.dataField.invalidValues->size() >=1
		else
			true
		endif
	post noMissing:
		if imputeType.imputeValue  = ValueImpute::Missing
		then
			self.getOutputDataField().missingValues->size() = 0
		else
			true
		endif
	post noInvalid:
		if imputeType.imputeValue  = ValueImpute::Invalid
		then
			self.getOutputDataField().invalidValues->size() = 0
		else
			true
		endif
	validateRowFilter(filterType:FilterType, matchingValue:MatchingValue)
	begin end	
	pre values:
		if filterType.oclIsTypeOf(FieldValue) then
			if matchingValue.oclIsTypeOf(Range) then
				self.field.dataField.oclAsType(Continuous).intervals->select(
				i | i.leftMargin <= matchingValue.oclAsType(Range).min.toReal() or 
				i.rightMargin >= matchingValue.oclAsType(Range).max.toReal())->size() >= 1
			else
				self.field.dataField.missingValues->size() >=1
			endif
		else true endif
	pre rows:
		if filterType.oclIsTypeOf(RowNumber) then
		(matchingValue.oclAsType(Range).max.toReal() - matchingValue.oclAsType(Range).min.toReal()) <= self.getInputDataDictionary(1).rows
		else true endif
	post noValues:
		if filterType.oclIsTypeOf(FieldValue) then
			if matchingValue.oclIsTypeOf(Range) then
				self.getOutputDataField().oclAsType(Continuous).intervals->select(
				i | i.leftMargin <= matchingValue.oclAsType(Range).min.toReal() or 
				i.rightMargin >= matchingValue.oclAsType(Range).max.toReal())->size() = 0
			else
				self.field.dataField.missingValues->size() = 0
			endif
		else true endif
	post noRows:
		if filterType.oclIsTypeOf(RowNumber) then
		(self.getInputDataDictionary(1).rows - self.getOutputDataDictionary(1).rows) = 
		(matchingValue.oclAsType(Range).max.toReal() - matchingValue.oclAsType(Range).min.toReal())
		else true endif
	validateRemoveDataField()
	begin end
	post removed:
		self.getOutputDataField().oclIsUndefined()
	validateMapping(maps:Set(Map))
	begin end
	pre inValue:
		maps->forAll(m | self.field.dataField.validValues->select(v | v.value = m.inValue)->size()>=1
					or self.field.dataField.invalidValues->select(v | v.value = m.inValue)->size()>=1
					or self.field.dataField.missingValues->select(v | v.value = m.inValue)->size()>=1)
	post noInValue:
		maps->forAll(m | self.getOutputDataField().validValues->select(v | v.value = m.inValue)->size()=0
					and self.getOutputDataField().invalidValues->select(v | v.value = m.inValue)->size()=0
					and self.getOutputDataField().missingValues->select(v | v.value = m.inValue)->size()=0)

	validateReplaceOutliers(operation:ImputeType, q1:PrimitiveValue, q3:PrimitiveValue, iqr:PrimitiveValue, multiqr:PrimitiveValue)
	begin end
	pre outliers:
		let min = q1.value.toReal()-multiqr.value.toReal()*iqr.value.toReal() in
		let max = q3.value.toReal()+multiqr.value.toReal()*iqr.value.toReal() in
		self.field.dataField.oclAsType(Continuous).intervals->select(i | i.leftMargin < min or i.rightMargin > max)->size() >= 1
	post noOutliers:
		let min = q1.value.toReal()-multiqr.value.toReal()*iqr.value.toReal() in
		let max = q3.value.toReal()+multiqr.value.toReal()*iqr.value.toReal() in
		self.field.dataField.oclAsType(Continuous).intervals->select(i | i.leftMargin < min or i.rightMargin > max)->size() = 0
	validateDiscretize(bins:Set(DiscretizeBin))
	begin end
	pre intervals:
	let intervals_in = self.field.dataField.oclAsType(Continuous).intervals in
		bins->forAll(dB | 
		intervals_in->select(int | int.rightMargin = dB.interval.rightMargin and 
		int.leftMargin = dB.interval.leftMargin and int.closure = dB.interval.closure)->size()=1)
	post bins:
	bins->forAll(dB | self.getOutputDataField().validValues->select(v | v.value = dB.binValue)->size()=1)
	post size:
		let intervals_in = self.field.dataField.oclAsType(Continuous).intervals in
		bins->forAll(dB | 
		intervals_in->select(int | int.rightMargin = dB.interval.rightMargin and 
		int.leftMargin = dB.interval.leftMargin and int.closure = dB.interval.closure
		)->asSequence()->at(1).count = self.getOutputDataField().validValues->select(
			v | v.value = dB.binValue)->asSequence()->at(1).count)

end		


constraints



